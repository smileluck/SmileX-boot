[toc]

----

# 前言

在 `lambda` 中了解了什么是函数式接口，以及 `@FunctionalInterface` 注解。

我们知道函数式接口中，**有且只有一个抽象方法的接口，但可以有多个非抽象方法的接口。**

而 `@FunctionalInterface` 注解是可以检查一个接口是否为函数式接口。只是在**编译时强制规范使用**。 如果接口是函数接口，编译通过；如果不是，编译失败。 

我们自定义函数式接口时，`@FuncationalInterface` 注解是可选的，就算我们不写这个注解，只要保证是函数式接口也是可以的。但是**建议加上**。

`Java 8` 在 `java.util.function` 包下预定了大量的函数式接口供我们使用。常用的有：

- 生产型 Supplier 接口
- Function 接口
- Consumer 接口
- Predicate 接口

# 生产型 Supplier 

`java.util.function.Supplier<T>` 接口仅包含一个无参的方法 `T get()`。用来获取一个泛型参指定类型的对象数据。

```java
@FunctionalInterface
public interface Supplier<T> {

    /**
     * Gets a result.
     *
     * @return a result
     */
    T get();
}
```

## 案例

```java
@Test
public void test() {
    String string = supplierGet(() -> {
        return "supplier test";
    });
    System.out.println(string);
}

private static <T> T supplierGet(Supplier<T> sup) {
	return sup.get();
}
```

# 消费型 Consumer

`java.util.function.Consumer<T>` 接口与 `Supplier` 接口相反，它是消费一个数据，不产生输出，其类型是一个泛型。`Consumer` 中包含抽象方法`void accept(T t)` 意思接受一个指定泛型的数据进行处理，此外还有一个默认实现方法 `Consumer<T> andThen(Consumer<? super T> after)`。

```java

@FunctionalInterface
public interface Consumer<T> {
    /**
     * Performs this operation on the given argument.
     *
     * @param t the input argument
     */
    void accept(T t);

    default Consumer<T> andThen(Consumer<? super T> after) {
        Objects.requireNonNull(after);
        return (T t) -> { accept(t); after.accept(t); };
    }
}
```

## 案例_accept

```java
@Test
    public void test() {
        consumerAccept("qweqweqwe", (item) -> {
            String s = new StringBuilder(item.toString()).reverse().toString();
            System.out.println(s);
        });
    }

    private static <T> void consumerAccept(T name, Consumer<T> com) {
        com.accept(name);
    }
}
```

这里无论 `Consumer` 都会将其做一次反转后，进行打印。

## 案例_andThen

```java
@Test
public void test2() {
    consumerAndThen("qwE123", (item) -> {
        System.out.println("先执行了我");
        String s = new StringBuilder(item.toString()).reverse().toString();
        System.out.println(s);
    }, item -> {
        System.out.println("后执行了我");
        String s = item.toUpperCase().toLowerCase();
        System.out.println(s);
    });
}

private static <T> void consumerAndThen(T name, Consumer<T> com, Consumer<T> com2) {
    com.andThen(com2).accept(name);
}
```

输出结果

```java
先执行了我
321Ewq
后执行了我
qwe123
```

这里需要注意的点是：

1. 都是对原数据进行了操作，如果是基本类型值不变，如果是引用对象，只修改了引用对象的内部值。
2. 在`consumer` 内部修改方法剧本变量的值，会提示异常`Variable used in lambda expression should be final or effectively final`。这是一个隐式的 `final`



# Function



